
<div id='nodeSection1'>Type guards</div>
<p><span class=rvts41><br></span></p>
<p><span class=rvts45>function</span><span class=rvts41> isDog(animal: </span><span class=rvts110>Dog</span><span class=rvts41> | </span><span class=rvts110>Cat</span><span class=rvts41>): </span><span class=rvts52>animal </span><span class=rvts50>is</span><span class=rvts52> Dog</span><span class=rvts41> {&nbsp; </span><span class=rvts39>// </span><span class=rvts44>user-defined type guard function</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp; </span><span class=rvts45>return</span><span class=rvts41> (&lt;</span><span class=rvts110>Dog</span><span class=rvts41>&gt;animal).bark !== </span><span class=rvts45>undefined</span><span class=rvts41>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts39>// retunrs a boolean indicating if the parameter animal is of type Dog</span></p>
<p><span class=rvts41>}</span></p>
<p><span class=rvts41><br></span></p>
<p class=rvps12><span class=rvts251>[</span><span class=rvts64>new</span><span class=rvts251> </span><span class=rvts110>Dog</span><span class=rvts251>(), </span><span class=rvts64>new</span><span class=rvts251> </span><span class=rvts110>Cat</span><span class=rvts251>()].filter(isDog)  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts252>// type guards can be used when filtering arrays</span></p>
<p><span class=rvts41><br></span></p>
<p><span class=rvts45>function</span><span class=rvts41> makeSomeNoise(animal: </span><span class=rvts110>Dog</span><span class=rvts41> | </span><span class=rvts110>Cat</span><span class=rvts41>): </span><span class=rvts45>void</span><span class=rvts41> {&nbsp;&nbsp; </span><span class=rvts39>// </span><span class=rvts44>explicit inference via a user-definied type guard function</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp; </span><span class=rvts45>if</span><span class=rvts41> (isDog(animal)) {</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animal.bark();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts39>// animal is now assumed to be of type Dog, so bark() can be called</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp; } </span><span class=rvts45>else</span><span class=rvts41> {</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animal.meow();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts39>// in the else branch animal is automatically typed as "not Dog" (=Cat)</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp; }</span></p>
<p><span class=rvts41>}</span></p>
<p><span class=rvts41><br></span></p>
<p><span class=rvts45>function</span><span class=rvts41> myFunction(p: </span><span class=rvts45>number</span><span class=rvts41> | </span><span class=rvts45>string</span><span class=rvts41>): </span><span class=rvts45>void</span><span class=rvts41> {&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts39>// </span><span class=rvts44>implicit inference via typeof</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp; </span><span class=rvts45>if</span><span class=rvts41> (</span><span class=rvts45>typeof</span><span class=rvts41> p === </span><span class=rvts42>"number"</span><span class=rvts41>) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts39>// this works as type guard only for number, string, boolean and symbol</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp; } </span><span class=rvts45>else</span><span class=rvts41> {</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p = p.substr(1);</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp; }</span></p>
<p><span class=rvts41>}</span></p>
<p><span class=rvts41><br></span></p>
<p><span class=rvts45>function</span><span class=rvts41> makeSomeNoise(animal: </span><span class=rvts110>Dog</span><span class=rvts41> | </span><span class=rvts110>Cat</span><span class=rvts41>): </span><span class=rvts45>void</span><span class=rvts41> {&nbsp;&nbsp; </span><span class=rvts39>// </span><span class=rvts44>implicit inference via instanceof</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp; </span><span class=rvts45>if</span><span class=rvts41> (animal </span><span class=rvts45>instanceof</span><span class=rvts41> </span><span class=rvts110>Dog</span><span class=rvts41>) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts39>// instanceof works as an automatic typeguard as well</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animal.bark();</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp; } </span><span class=rvts45>else</span><span class=rvts41> {</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; animal.meow();</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp; }</span></p>
<p><span class=rvts41>}</span></p>
<p><span class=rvts41><br></span></p>
<p><span class=rvts251>[</span><span class=rvts289>"abc"</span><span class=rvts251>, 3, </span><span class=rvts64>true</span><span class=rvts251>].filter(</span></p>
<p class=rvps12><span class=rvts251>&nbsp;&nbsp;&nbsp; (x): x </span><span class=rvts64>is</span><span class=rvts251> </span><span class=rvts64>number</span><span class=rvts251> =&gt; </span><span class=rvts289>"number"</span><span class=rvts251> === </span><span class=rvts64>typeof</span><span class=rvts251> x</span></p>
<p class=rvps12><span class=rvts251>);</span></p>
<p class=rvps12><span class=rvts251><br></span></p>
<p class=rvps12><span class=rvts64>class</span><span class=rvts251> </span><span class=rvts288>Box</span><span class=rvts251>&lt;</span><span class=rvts288>T</span><span class=rvts251>&gt; {</span></p>
<p class=rvps12><span class=rvts251>    value?: </span><span class=rvts288>T</span><span class=rvts251>;</span></p>
<p class=rvps12><span class=rvts251>    hasValue(): </span><span class=rvts64>this</span><span class=rvts251> is { value: T } {      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts252>// can assert that optional properties are present</span></p>
<p class=rvps12><span class=rvts251>     &nbsp;&nbsp; </span><span class=rvts64>return</span><span class=rvts251> </span><span class=rvts64>this</span><span class=rvts251>.value !== </span><span class=rvts64>undefined</span><span class=rvts251>;</span></p>
<p class=rvps12><span class=rvts251>    }</span></p>
<p class=rvps12><span class=rvts251>}</span></p>
<p><span class=rvts41><br></span></p>
<p><span class=rvts110><br></span></p>
<p><span class=rvts110><br></span></p>
<div id='nodeSection2'>Detecting properties with "in"</div>
<p><span class=rvts41><br></span></p>
<p class=rvps12><span class=rvts64>const my</span><span class=rvts251>Object : </span><span class=rvts64>object </span><span class=rvts251>= { };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts252>// the type is widened to string | number</span></p>
<p class=rvps12><span class=rvts41><br></span></p>
<p class=rvps12><span class=rvts64>if (</span><span class=rvts289>"property" </span><span class=rvts64>if</span><span class=rvts289> </span><span class=rvts64>my</span><span class=rvts251>Object)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts252>// check if the object has a property with the given name</span></p>
<p class=rvps12><span class=rvts64><br></span></p>
<p><span class=rvts110><br></span></p>
<div id='nodeSection3'>Satisfies</div>
<p><span class=rvts41><br></span></p>
<p class=rvps12><span class=rvts64><br></span></p>
<p class=rvps12><span class=rvts64>const </span><span class=rvts251>variable : </span><span class=rvts64>string</span><span class=rvts251> | </span><span class=rvts64>number </span><span class=rvts251>= </span><span class=rvts289>"..."</span><span class=rvts251>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts252>// the type is widened to string | number</span></p>
<p class=rvps12><span class=rvts41><br></span></p>
<p class=rvps12><span class=rvts64>const </span><span class=rvts251>variable = </span><span class=rvts289>"..."</span><span class=rvts251> </span><span class=rvts64>satisfies</span><span class=rvts251> </span><span class=rvts64>string</span><span class=rvts251> | </span><span class=rvts64>number</span><span class=rvts251>;&nbsp;&nbsp; </span><span class=rvts252>// the value is checked but the type remains "..."</span></p>
<p class=rvps12><span class=rvts41><br></span></p>
<p class=rvps12><span class=rvts41><br></span></p>
<p><span class=rvts110><br></span></p>
<div id='nodeSection4'>Discriminated unions</div>
<p><span class=rvts41><br></span></p>
<p><span class=rvts45>interface</span><span class=rvts41> Rectangle {</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp; kind: </span><span class=rvts42>"rectangle"</span><span class=rvts41>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts39>// all relevant types have a unique string literal property</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp; width: </span><span class=rvts45>number</span><span class=rvts41>;</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp; height: </span><span class=rvts45>number</span><span class=rvts41>;</span></p>
<p><span class=rvts41>}</span></p>
<p><span class=rvts41><br></span></p>
<p><span class=rvts45>interface</span><span class=rvts41> Circle {</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp; kind: </span><span class=rvts42>"circle"</span><span class=rvts41>;</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp; radius: </span><span class=rvts45>number</span><span class=rvts41>;</span></p>
<p><span class=rvts41>}</span></p>
<p><span class=rvts41><br></span></p>
<p><span class=rvts45>type</span><span class=rvts41> Shape = Rectangle | Circle;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts39>// the types are combined into a union</span></p>
<p><span class=rvts41><br></span></p>
<p><span class=rvts45>function</span><span class=rvts41> area(s: Shape) : </span><span class=rvts45>number</span><span class=rvts41> {</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp; </span><span class=rvts45>switch</span><span class=rvts41> (s.kind) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts39>// the uniqe string literal is evaluated</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts45>case</span><span class=rvts41> </span><span class=rvts42>"rectangle"</span><span class=rvts41>:</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts45>return</span><span class=rvts41> s.height * s.width;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts39>// in each case-branch the correct type is inferred automatically</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts45>case</span><span class=rvts41> </span><span class=rvts42>"circle"</span><span class=rvts41>:</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts45>return</span><span class=rvts41> Math.PI * s.radius ** 2;</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts45>default</span><span class=rvts41>:</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts45>return</span><span class=rvts41> assertNever(s);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts39>// use this construct to ensure that all possible types have been considered</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp; }</span></p>
<p><span class=rvts41>}</span></p>
<p><span class=rvts41><br></span></p>
<p><span class=rvts45>function</span><span class=rvts41> assertNever(x: </span><span class=rvts45>never</span><span class=rvts41>): </span><span class=rvts45>never</span><span class=rvts41> {</span></p>
<p><span class=rvts41>&nbsp;&nbsp;&nbsp; </span><span class=rvts45>throw</span><span class=rvts41> </span><span class=rvts45>new</span><span class=rvts41> Error(</span><span class=rvts42>"Unexpected object: "</span><span class=rvts41> + x);</span></p>
<p><span class=rvts41>}</span></p>
<p><span class=rvts41><br></span></p>
<p><span class=rvts41><br></span></p>
<p><span class=rvts110><br></span></p>
<div id='nodeSection5'>Exhaustive type checking</div>
<p><span class=rvts41><br></span></p>
<p class=rvps12><span class=rvts64>switch</span><span class=rvts251> (mode) {</span></p>
<p class=rvps12><span class=rvts251>    </span><span class=rvts64>case</span><span class=rvts251> </span><span class=rvts289>"read"</span><span class=rvts251>: </span><span class=rvts64>break</span><span class=rvts251>;</span></p>
<p class=rvps12><span class=rvts251>    </span><span class=rvts64>case</span><span class=rvts251> </span><span class=rvts289>"write"</span><span class=rvts251>: </span><span class=rvts64>break</span></p>
<p class=rvps12><span class=rvts251>    </span><span class=rvts64>default</span><span class=rvts251>:</span></p>
<p class=rvps12><span class=rvts251>        </span><span class=rvts64>const</span><span class=rvts251> impossible: </span><span class=rvts306>never</span><span class=rvts251> = mode;    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts252>// assign the value to "never" to guarantee that the</span></p>
<p class=rvps12><span class=rvts251>        console.log(impossible);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts252>// cases above are exhaustive</span></p>
<p class=rvps12><span class=rvts251>}</span></p>
<p><br></p>
<p><br></p>

