
<div id='nodeSection1'>Storing and querying XML columns</div>
<p><span class=rvts12><br></span></p>
<p><span class=rvts64>CREATE</span><span class=rvts61> </span><span class=rvts64>XML</span><span class=rvts61> </span><span class=rvts64>SCHEMA</span><span class=rvts61> </span><span class=rvts64>COLLECTION</span><span class=rvts61> my_xsd_schema </span><span class=rvts64>AS</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- optional: XSDs can be imported so that XML data can be validated automatically</span></p>
<p><span class=rvts61>&nbsp;&nbsp;&nbsp; </span><span class=rvts66>'&lt;?xml version="1.0"&gt;</span></p>
<p><span class=rvts66>&nbsp;&nbsp;&nbsp; &lt;xsd:schema ...&gt;</span></p>
<p><span class=rvts66>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</span></p>
<p><span class=rvts66>&nbsp;&nbsp;&nbsp; &lt;/xsd:schema&gt;'</span><span class=rvts63>;</span></p>
<p><span class=rvts61><br></span></p>
<p><span class=rvts63>{</span><span class=rvts64>ALTER</span><span class=rvts63>|</span><span class=rvts64>DROP</span><span class=rvts63>}</span><span class=rvts61> </span><span class=rvts64>XML</span><span class=rvts61> </span><span class=rvts64>SCHEMA</span><span class=rvts61> </span><span class=rvts64>COLLECTION</span><span class=rvts61> </span><span class=rvts63>...;</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- schemas can be modified and deleted as well</span></p>
<p><span class=rvts61><br></span></p>
<p><span class=rvts64>CREATE</span><span class=rvts61> </span><span class=rvts64>TABLE</span><span class=rvts61> my_table&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- tables can contain XML columns which (if not indexed) are stored as BLOBs</span></p>
<p><span class=rvts63>(</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- and parsed at runtime</span></p>
<p><span class=rvts61>&nbsp;&nbsp;&nbsp; id </span><span class=rvts64>INT</span><span class=rvts61> </span><span class=rvts64>IDENTITY</span><span class=rvts61> </span><span class=rvts63>NOT</span><span class=rvts61> </span><span class=rvts63>NULL</span><span class=rvts61> </span><span class=rvts64>PRIMARY</span><span class=rvts61> </span><span class=rvts64>KEY</span><span class=rvts63>,</span></p>
<p><span class=rvts61>&nbsp;&nbsp;&nbsp; </span><span class=rvts64>xml</span><span class=rvts61> </span><span class=rvts64>XML</span><span class=rvts63>({</span><span class=rvts61>DOCUMENT</span><span class=rvts63>|</span><span class=rvts61>CONTENT</span><span class=rvts63>}</span><span class=rvts61> my_xsd_schema</span><span class=rvts63>)</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- XML columns can optionally be associated with an XSD schema</span></p>
<p><span class=rvts63>);</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- (DOCUMENT allows full documents only, while CONTENT allows fragments as well)</span></p>
<p><span class=rvts61><br></span></p>
<p><span class=rvts64>CREATE</span><span class=rvts61> </span><span class=rvts64>PRIMARY</span><span class=rvts61> </span><span class=rvts64>XML</span><span class=rvts61> </span><span class=rvts64>INDEX</span><span class=rvts61> my_primary_index&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- a primary XML index covers all tags and attributes within the document</span></p>
<p><span class=rvts61>&nbsp;&nbsp;&nbsp; </span><span class=rvts64>ON</span><span class=rvts61> my_table</span><span class=rvts63>(</span><span class=rvts64>xml</span><span class=rvts63>);</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- the XML document is stored in a parsed format (speeding up queries)</span></p>
<p><span class=rvts61><br></span></p>
<p><span class=rvts64>CREATE</span><span class=rvts61> </span><span class=rvts64>XML</span><span class=rvts61> </span><span class=rvts64>INDEX</span><span class=rvts61> idx_my_secondary_index_1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- secondary indices can be built upon primary indices and can be of type:</span></p>
<p><span class=rvts61>&nbsp;&nbsp;&nbsp; </span><span class=rvts64>ON</span><span class=rvts61> my_table</span><span class=rvts63>(</span><span class=rvts64>xml</span><span class=rvts63>)</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- PATH: indexes the document structure (speeds up path expressions like XPath)</span></p>
<p><span class=rvts61>&nbsp;&nbsp;&nbsp; </span><span class=rvts64>USING</span><span class=rvts61> </span><span class=rvts64>XML</span><span class=rvts61> </span><span class=rvts64>INDEX</span><span class=rvts61> my_primary_index&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- VALUE: indexes element and attribute values (speeds up seeking for values without knowing the element)</span></p>
<p><span class=rvts61>&nbsp;&nbsp;&nbsp; </span><span class=rvts64>FOR</span><span class=rvts61> </span><span class=rvts63>{</span><span class=rvts64>PATH</span><span class=rvts63>|</span><span class=rvts61>VALUE</span><span class=rvts63>|</span><span class=rvts61>PROPERTY</span><span class=rvts63>};</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- PROPERTY: indexes properties</span></p>
<p><span class=rvts61><br></span></p>
<p><span class=rvts64>INSERT</span><span class=rvts61> </span><span class=rvts64>INTO</span><span class=rvts61> my_table</span><span class=rvts64> </span><span class=rvts63>(</span><span class=rvts64>xml</span><span class=rvts63>)</span><span class=rvts61> </span><span class=rvts64>VALUES</span><span class=rvts63>(</span></p>
<p><span class=rvts61>&nbsp;&nbsp;&nbsp; </span><span class=rvts66>'&lt;?xml version="1.0"?&gt;</span></p>
<p><span class=rvts66>&nbsp;&nbsp;&nbsp; &lt;locations&gt;</span></p>
<p><span class=rvts66>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;city&gt;Melbourne&lt;/city&gt;</span></p>
<p><span class=rvts66>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;city&gt;Auckland&lt;/city&gt;</span></p>
<p><span class=rvts66>&nbsp;&nbsp;&nbsp; &lt;/locations&gt;'</span></p>
<p><span class=rvts63>);</span></p>
<p><span class=rvts61><br></span></p>
<p><span class=rvts64>SELECT</span><span class=rvts61> </span><span class=rvts64>xml</span><span class=rvts63>.</span><span class=rvts61>query</span><span class=rvts63>(</span><span class=rvts66>'/locations/city'</span><span class=rvts63>),</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- apply an XQuery to an XML column and return its result</span></p>
<p><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts64>xml</span><span class=rvts63>.</span><span class=rvts61>exist</span><span class=rvts63>(</span><span class=rvts66>'/locations/city'</span><span class=rvts63>),</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- returns 1 (match), 0 (no match) or NULL</span></p>
<p><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts64>xml</span><span class=rvts63>.</span><span class=rvts61>value</span><span class=rvts63>(</span><span class=rvts66>'city[0]'</span><span class=rvts63>,</span><span class=rvts61> </span><span class=rvts66>'varchar(50)'</span><span class=rvts63>),</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- return the value of the XQuery result (must contain at least one match</span></p>
<p><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts64>FROM</span><span class=rvts61> my_table</span><span class=rvts63>;</span><span class=rvts61>&nbsp; </span></p>
<p><span class=rvts61><br></span></p>
<p><span class=rvts9><br></span></p>
<div id='nodeSection2'>Parsing and querying XML documents</div>
<p><span class=rvts12><br></span></p>
<p><span class=rvts64>DECLARE</span><span class=rvts61> @handle </span><span class=rvts64>INT</span><span class=rvts63>;</span></p>
<p><span class=rvts64>EXECUTE</span><span class=rvts61> </span><span class=rvts65>sp_xml_preparedocument</span><span class=rvts64> </span><span class=rvts61>@handle </span><span class=rvts64>OUTPUT</span><span class=rvts63>,</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- parse an XML document and return a handle to the internal DOM-tree representation</span></p>
<p><span class=rvts61>&nbsp;&nbsp;&nbsp; </span><span class=rvts66>'&lt;?xml version="1.0"?&gt;</span></p>
<p><span class=rvts66>&nbsp;&nbsp;&nbsp; &lt;locations&gt;</span></p>
<p><span class=rvts66>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;city&gt;&lt;name&gt;Melbourne&lt;/name&gt;&lt;/city&gt;</span></p>
<p><span class=rvts66>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;city&gt;&lt;name&gt;Auckland&lt;/name&gt;&lt;/city&gt;</span></p>
<p><span class=rvts66>&nbsp;&nbsp;&nbsp; &lt;/locations&gt;'</span></p>
<p><span class=rvts61><br></span></p>
<p><span class=rvts64>SELECT</span><span class=rvts61> </span><span class=rvts63>*</span><span class=rvts61> </span><span class=rvts64>FROM</span><span class=rvts61> </span><span class=rvts64>OPENXML</span><span class=rvts63>(</span><span class=rvts61>@handle</span><span class=rvts63>,</span><span class=rvts66>'/locations/city'</span><span class=rvts63>,</span><span class=rvts61>1</span><span class=rvts63>)</span><span class=rvts61>&nbsp; </span><span class=rvts62>-- the results of an XPath expression can be converted to a table-like structure</span></p>
<p><span class=rvts61>&nbsp;&nbsp;&nbsp; </span><span class=rvts64>WITH </span><span class=rvts63>(</span><span class=rvts61>CityName </span><span class=rvts64>VARCHAR</span><span class=rvts63>(</span><span class=rvts61>50</span><span class=rvts63>)</span><span class=rvts61> </span><span class=rvts66>'name'</span><span class=rvts63>);</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- map result table columns (CityName) to XML element names (name)</span></p>
<p><span class=rvts61><br></span></p>
<p><span class=rvts9><br></span></p>
<div id='nodeSection3'>Converting SELECT results to XML</div>
<p><span class=rvts12><br></span></p>
<p><span class=rvts64>SELECT</span><span class=rvts61> </span><span class=rvts63>*</span><span class=rvts61> </span><span class=rvts64>FROM</span><span class=rvts61> my_table </span><span class=rvts64>FOR</span><span class=rvts61> </span><span class=rvts64>XML</span><span class=rvts61> </span><span class=rvts64>RAW</span><span class=rvts63>;</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- return only one column which contains an XML document comprising all original result set column values</span></p>
<p><span class=rvts64>SELECT</span><span class=rvts61> </span><span class=rvts63>*</span><span class=rvts61> </span><span class=rvts64>FROM</span><span class=rvts61> my_table </span><span class=rvts64>FOR</span><span class=rvts61> </span><span class=rvts64>XML</span><span class=rvts61> </span><span class=rvts64>AUTO</span><span class=rvts63>;</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- creates a parent node for each table from which data is being selected</span></p>
<p><span class=rvts64>SELECT</span><span class=rvts61> id "user/id" </span><span class=rvts64>FROM</span><span class=rvts61> my_table </span><span class=rvts64>FOR</span><span class=rvts61> </span><span class=rvts64>XML</span><span class=rvts61> </span><span class=rvts64>PATH</span><span class=rvts63>;</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- the column alias specifies where to place the value in the result XML document&nbsp; (use @ for attribute names)</span></p>
<p><span class=rvts64>SELECT</span><span class=rvts61> </span><span class=rvts73>[...]</span><span class=rvts61> </span><span class=rvts63>*</span><span class=rvts61> </span><span class=rvts64>FROM</span><span class=rvts61> customer </span><span class=rvts64>FOR</span><span class=rvts61> </span><span class=rvts64>XML</span><span class=rvts61> </span><span class=rvts64>EXPLICIT</span><span class=rvts63>;</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- complicated syntax, see Microsoft SQL Server 2016 for beginners chapter 28.3.2.3</span></p>
<p><span class=rvts61><br></span></p>
<p><span class=rvts64>SELECT</span><span class=rvts61> </span><span class=rvts63>...</span><span class=rvts61> </span><span class=rvts64>FOR</span><span class=rvts61> </span><span class=rvts64>XML</span><span class=rvts61> </span><span class=rvts63>{</span><span class=rvts64>RAW</span><span class=rvts63>|...},</span><span class=rvts61> </span><span class=rvts64>TYPE</span><span class=rvts63>;</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- return a one row/one column result set (XML fragment)</span></p>
<p><span class=rvts64>SELECT</span><span class=rvts61> </span><span class=rvts63>...</span><span class=rvts61> </span><span class=rvts64>FOR</span><span class=rvts61> </span><span class=rvts64>XML</span><span class=rvts61> </span><span class=rvts63>{</span><span class=rvts64>RAW</span><span class=rvts63>|...},</span><span class=rvts61> </span><span class=rvts64>ELEMENTS</span><span class=rvts61> </span><span class=rvts64>WITH</span><span class=rvts61> </span><span class=rvts64>XSINIL</span><span class=rvts63>;</span><span class=rvts61> </span><span class=rvts62>-- each column is a (child) element, NULL values are represented as xsi:nil</span></p>
<p><span class=rvts64>SELECT</span><span class=rvts61> </span><span class=rvts63>...</span><span class=rvts61> </span><span class=rvts64>FOR</span><span class=rvts61> </span><span class=rvts64>XML</span><span class=rvts61> </span><span class=rvts63>{</span><span class=rvts64>RAW</span><span class=rvts63>|...},</span><span class=rvts61> </span><span class=rvts64>ROOT</span><span class=rvts63>(</span><span class=rvts66>'MyRoot'</span><span class=rvts63>);</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- wrap all lines into a root element with the given name</span></p>
<p><span class=rvts62><br></span></p>
<p><span class=rvts9><br></span></p>
<div id='nodeSection4'>JSON (SQL Server 2016)</div>
<p><span class=rvts12><br></span></p>
<p><span class=rvts64>CREATE</span><span class=rvts61> </span><span class=rvts64>TABLE</span><span class=rvts61> my_table</span></p>
<p><span class=rvts63>(</span></p>
<p><span class=rvts61>&nbsp;&nbsp;&nbsp; id </span><span class=rvts64>INT</span><span class=rvts61> </span><span class=rvts64>IDENTITY</span><span class=rvts61> </span><span class=rvts63>NOT</span><span class=rvts61> </span><span class=rvts63>NULL,</span></p>
<p><span class=rvts61>&nbsp;&nbsp;&nbsp; json </span><span class=rvts64>NVARCHAR</span><span class=rvts63>(</span><span class=rvts61>1000</span><span class=rvts63>)</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- JSON data is stored as simple text (there is no special data type)</span></p>
<p><span class=rvts63>);</span></p>
<p><span class=rvts61><br></span></p>
<p><span class=rvts64>INSERT</span><span class=rvts61> </span><span class=rvts64>INTO</span><span class=rvts61> my_table</span><span class=rvts64> </span><span class=rvts63>(</span><span class=rvts61>json</span><span class=rvts63>)</span><span class=rvts61> </span><span class=rvts64>VALUES</span></p>
<p><span class=rvts63>(</span></p>
<p><span class=rvts61>&nbsp;&nbsp;&nbsp; </span><span class=rvts66>N'{"person":{"name":"David","age":"38"}}'</span></p>
<p><span class=rvts63>);</span></p>
<p><span class=rvts61><br></span></p>
<p><span class=rvts64>SELECT</span><span class=rvts61> isjson</span><span class=rvts63>(</span><span class=rvts61>json</span><span class=rvts63>),</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- check if the given column contains a JSON string (1) or not (0)</span></p>
<p><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; json_value</span><span class=rvts63>(</span><span class=rvts61>json</span><span class=rvts63>,</span><span class=rvts61> </span><span class=rvts66>N'$.person[0].name'</span><span class=rvts63>),</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- retrieve a scalar value from the given JSON path</span></p>
<p><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; json_query</span><span class=rvts63>(</span><span class=rvts61>json</span><span class=rvts63>,</span><span class=rvts61> </span><span class=rvts66>N'$.person'</span><span class=rvts63>)</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- retrieve a (sub-) object or an array from a JSON path</span></p>
<p><span class=rvts61><br></span></p>
<p><span class=rvts64>DECLARE</span><span class=rvts61> @json </span><span class=rvts64>NVARCHAR</span><span class=rvts63>(</span><span class=rvts67>MAX</span><span class=rvts63>)</span><span class=rvts61> </span><span class=rvts63>=</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- in-memory JSON objects can be queried like tables</span></p>
<p><span class=rvts61>&nbsp;&nbsp;&nbsp; </span><span class=rvts66>N'{"person":{"name":"David","age":"38"}}'</span><span class=rvts63>;</span></p>
<p><span class=rvts64>SELECT</span><span class=rvts61> [key]</span><span class=rvts63>,</span><span class=rvts61> value </span></p>
<p><span class=rvts61>&nbsp;&nbsp;&nbsp; </span><span class=rvts64>FROM</span><span class=rvts61> OPENJSON</span><span class=rvts63>(</span><span class=rvts61>@json</span><span class=rvts63>,</span><span class=rvts61> </span><span class=rvts66>N'$.person[0].name'</span><span class=rvts63>);</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- OPENJSON uses an XPath like query specification</span></p>
<p><span class=rvts61><br></span></p>
<p><span class=rvts64>SELECT</span><span class=rvts61> </span><span class=rvts63>*</span><span class=rvts61> </span><span class=rvts64>FROM</span><span class=rvts61> my_table </span><span class=rvts64>FOR</span><span class=rvts61> JSON </span><span class=rvts63>{</span><span class=rvts64>AUTO</span><span class=rvts63>|</span><span class=rvts64>PATH</span><span class=rvts63>};</span><span class=rvts61>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts62>-- return the result of a regular SELECT statement as JSON object</span></p>
<p><span class=rvts62><br></span></p>
<p><br></p>
<p><br></p>

