
<div id='nodeSection1'>Generics</div>
<p><span class=rvts12><br></span></p>
<p class=rvps12><span class=rvts265>class </span><span class=rvts274>MyClass</span><span class=rvts262>[</span><span class=rvts277>T</span><span class=rvts262>]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts263>// MyClass[MyBase] and MyClass[MyChild] are mutually incompatible</span></p>
<p class=rvps12><span class=rvts263><br></span></p>
<p class=rvps12><span class=rvts265>class </span><span class=rvts274>MyClass</span><span class=rvts262>[</span><span class=rvts277>T </span><span class=rvts262>&gt;: </span><span class=rvts274>SomeClass</span><span class=rvts262>]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts263>// T must be SomeClass (or one of its parents)</span></p>
<p class=rvps12><span class=rvts265>class </span><span class=rvts274>MyClass</span><span class=rvts262>[</span><span class=rvts277>T </span><span class=rvts262>&lt;: </span><span class=rvts274>SomeClass</span><span class=rvts262>]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts263>// T must be SomeClass (or one of its children)</span></p>
<p class=rvps12><span class=rvts265>class </span><span class=rvts274>MyClass</span><span class=rvts262>[</span><span class=rvts277>T </span><span class=rvts262>&lt;: </span><span class=rvts277>Ordered</span><span class=rvts262>[</span><span class=rvts277>T</span><span class=rvts262>]]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts263>// T must implement the trait Ordered[T]</span></p>
<p class=rvps12><span class=rvts263><br></span></p>
<p class=rvps12><span class=rvts265>class </span><span class=rvts274>MyClass</span><span class=rvts262>[</span><span class=rvts277>+T</span><span class=rvts262>]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts263>// allows upwards casting val x : MyClass[Base] = MyClass[Child]()</span></p>
<p class=rvps12><span class=rvts265>class </span><span class=rvts274>MyClass</span><span class=rvts262>[</span><span class=rvts277>-T</span><span class=rvts262>]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts263>// allows downwards casting val x : MyClass[Child] = MyClass[Base]()</span></p>
<p class=rvps12><span class=rvts263><br></span></p>
<p class=rvps12><span class=rvts265>class </span><span class=rvts274>Stack</span><span class=rvts262>[</span><span class=rvts277>+T</span><span class=rvts262>] () {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts263>// +T allows upcasting (e.g. Stack[Child] can be assigned to Stack[Base])</span></p>
<p class=rvps12><span class=rvts263>&nbsp; </span><span class=rvts265>def </span><span class=rvts262>push[</span><span class=rvts277>U </span><span class=rvts262>&gt;: </span><span class=rvts277>T</span><span class=rvts262>](x: </span><span class=rvts277>U</span><span class=rvts262>) = </span><span class=rvts265>new </span><span class=rvts262>Stack[</span><span class=rvts277>U</span><span class=rvts262>]()&nbsp;&nbsp; </span><span class=rvts263>// push() accepts parent class objects, but returns a new (immutable) parent-type stack </span></p>
<p class=rvps12><span class=rvts263>&nbsp; </span><span class=rvts265>def </span><span class=rvts262>pop() : </span><span class=rvts277>T </span><span class=rvts262>= ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts263>// Stack[Child].pop() returns Child, Stack[Base].pop() returns Base</span></p>
<p class=rvps12><span class=rvts262>}</span></p>
<p class=rvps12><span class=rvts262><br></span></p>
<p class=rvps12><span class=rvts265>class </span><span class=rvts274>OutputChannel</span><span class=rvts262>[</span><span class=rvts277>-T</span><span class=rvts262>] {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts263>// new OutputChannel[AnyRef]() (which works for any object) can be assigned to OutputChannel[String] </span></p>
<p class=rvps12><span class=rvts263>&nbsp; </span><span class=rvts265>def </span><span class=rvts262>write(x: </span><span class=rvts277>T</span><span class=rvts262>): Unit = println(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts263>// when calling OutputChannel[String].write(), the parameter (String) still validates AnyRef </span></p>
<p class=rvps12><span class=rvts262>}</span></p>
<p class=rvps12><span class=rvts262><br></span></p>
<p class=rvps12><span class=rvts265>trait </span><span class=rvts274>Function1</span><span class=rvts262>[</span><span class=rvts277>-S</span><span class=rvts262>, </span><span class=rvts277>+T</span><span class=rvts262>] {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts263>// default type for x =&gt; y arrow functions</span></p>
<p class=rvps12><span class=rvts263>&nbsp; </span><span class=rvts265>def </span><span class=rvts262>apply(x: </span><span class=rvts277>S</span><span class=rvts262>): </span><span class=rvts277>T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts263>// accepts more specific input parameters and allows upcasting the result</span></p>
<p class=rvps12><span class=rvts262>}</span></p>
<p class=rvps12><span class=rvts262><br></span></p>
<p class=rvps12><span class=rvts263><br></span></p>
<p class=rvps12><span class=rvts262>myObject.asInstanceOf[</span><span class=rvts274>MyClass</span><span class=rvts262>[</span><span class=rvts274>Base</span><span class=rvts262>]]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts263>// forced type conversion (no compile-time check)</span></p>
<p class=rvps12><span class=rvts263><br></span></p>
<p><span class=rvts9><br></span></p>
<div id='nodeSection2'>Inheritance</div>
<p><span class=rvts12><br></span></p>
<p class=rvps12><span class=rvts265>class </span><span class=rvts274>Food</span></p>
<p class=rvps12><span class=rvts265>class </span><span class=rvts274>Grass </span><span class=rvts265>extends </span><span class=rvts262>Food</span></p>
<p class=rvps12><span class=rvts265>class </span><span class=rvts274>Fish&nbsp; </span><span class=rvts265>extends </span><span class=rvts262>Food</span></p>
<p class=rvps12><span class=rvts262><br></span></p>
<p class=rvps12><span class=rvts265>abstract class </span><span class=rvts274>Animal </span><span class=rvts262>{</span></p>
<p class=rvps12><span class=rvts262>&nbsp; </span><span class=rvts265>type </span><span class=rvts277>SuitableFood </span><span class=rvts262>&lt;: </span><span class=rvts274>Food&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts263>// use the type as a parameter rather than specifying Animal[T]</span></p>
<p class=rvps12><span class=rvts263>&nbsp; </span><span class=rvts265>def </span><span class=rvts262>eat(food: </span><span class=rvts277>SuitableFood</span><span class=rvts262>): Unit</span></p>
<p class=rvps12><span class=rvts262>}</span></p>
<p class=rvps12><span class=rvts262><br></span></p>
<p class=rvps12><span class=rvts265>class </span><span class=rvts274>Cow </span><span class=rvts265>extends </span><span class=rvts262>Animal {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts263>// inherit from the non-generic class</span></p>
<p class=rvps12><span class=rvts263>&nbsp; </span><span class=rvts265>type </span><span class=rvts277>SuitableFood </span><span class=rvts262>= </span><span class=rvts274>Grass&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts263>// ...and specify the type as a property</span></p>
<p class=rvps12><span class=rvts263>&nbsp; </span><span class=rvts265>override def </span><span class=rvts262>eat(food: </span><span class=rvts274>Grass</span><span class=rvts262>): Unit = ()</span></p>
<p class=rvps12><span class=rvts262>}</span></p>
<p class=rvps12><span class=rvts262><br></span></p>
<p class=rvps12><span class=rvts265>val </span><span class=rvts262>cow = </span><span class=rvts265>new </span><span class=rvts262>Cow()</span></p>
<p class=rvps12><span class=rvts280>cow.eat(</span><span class=rvts281>new </span><span class=rvts280>Food)</span></p>
<p class=rvps12><span class=rvts262>cow.eat(</span><span class=rvts265>new </span><span class=rvts262>Grass)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts263>// ok - while the type is known to be Cow, the SuitableFood is known to be Grass</span></p>
<p class=rvps12><span class=rvts280>cow.eat(</span><span class=rvts281>new </span><span class=rvts280>Fish)</span></p>
<p class=rvps12><span class=rvts263><br></span></p>
<p class=rvps12><span class=rvts265>val </span><span class=rvts262>animal : </span><span class=rvts274>Animal </span><span class=rvts262>= cow</span></p>
<p class=rvps12><span class=rvts280>animal.eat(</span><span class=rvts281>new </span><span class=rvts280>Food)</span></p>
<p class=rvps12><span class=rvts280>animal.eat(</span><span class=rvts281>new </span><span class=rvts280>Grass)</span><span class=rvts262>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class=rvts263>// nok - once cast to Animal, SuitableFood is abstract and not known</span></p>
<p class=rvps12><span class=rvts280>animal.eat(</span><span class=rvts281>new </span><span class=rvts280>Fish)</span></p>
<p class=rvps12><span class=rvts280><br></span></p>
<p><br></p>
<p><br></p>

